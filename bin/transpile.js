"use strict";
exports.__esModule = true;
console.log('test');
// this example will create a simple typescript source file programmatically, parse it to AST Nodes and then 
// use TypeScript Transformations to manipulate some ot its nodes (changing  particular arithmetic expressions). 
// Finally , the transformed AST will be printed back to another source file as a string
// (Note: I've taken this example from somewhere else some credits are not mine - but since there's limited typescript 
// documentation I think is a good idea to duplicate this... )
var ts = require("typescript");
var fs = require("fs");
var path = require("path");
var program = require("commander");
program.version('1.0.0')
    .option('-i, --input <item>', 'Input path')
    .option('-o, --output <item>', 'Ouptut path')
    .parse(process.argv);
var inputDir = program.input ? program.input : process.cwd();
var outputPath = program.output ? program.output : process.cwd() + path.sep + 'worker-postable-generated.ts';
console.log(inputDir, outputPath);
var walkSync = function (dir, filelist) {
    var files = fs.readdirSync(dir);
    filelist = filelist || [];
    files.forEach(function (file) {
        if (fs.statSync(dir + file).isDirectory()) {
            var nextPath = path.normalize(dir + path.sep + file + path.sep);
            filelist = walkSync(nextPath, filelist);
        }
        else {
            var filename = path.normalize(dir + path.sep + file);
            if (/\.ts?/.test(path.extname(filename)))
                filelist.push(filename);
        }
    });
    return filelist;
};
var filelist = walkSync(inputDir + path.sep, []);
console.log(filelist);
var sourceFiles = [];
for (var i = 0; i < filelist.length; i++) {
    var filepath = filelist[i];
    var source = fs.readFileSync(filepath).toString();
    if (source.indexOf('// Auto generated by worker-postable') == 0)
        continue;
    var sourceFile = ts.createSourceFile(filepath, source, ts.ScriptTarget.ES2015, true, ts.ScriptKind.TS);
    sourceFiles.push(sourceFile);
}
var generated = generate(sourceFiles);
fs.writeFileSync(outputPath, generated);
// Two-pass
// First pass : get all classes to recognize dependecy between classess (eg: extends)
// Second pass : generate classes
var ClassNode = /** @class */ (function () {
    function ClassNode() {
    }
    return ClassNode;
}());
function generate(sourceFiles) {
    var usingClasses = new Set();
    var classess = new Array();
    sourceFiles.forEach(function (node) {
        __pregenerate(node, usingClasses);
        __generate(node, usingClasses, classess);
    });
    var exports = __generateExports(classess);
    var printer = ts.createPrinter();
    var resultString = '// Auto generated by worker-postable\n';
    console.log(classess.length);
    var sf = ts.createSourceFile('a', '', ts.ScriptTarget.ES2017);
    for (var i = 0; i < classess.length; i++) {
        var str = printer.printNode(ts.EmitHint.Unspecified, classess[i], sf);
        resultString += str + '\n';
    }
    var storeRegister = __generateRegister(classess);
    resultString += storeRegister + '\n';
    resultString += printer.printNode(ts.EmitHint.Unspecified, exports, sf) + '\n';
    return resultString;
}
function __pregenerate(node, usingClasses) {
    function generate(node) {
        if (ts.isClassDeclaration(node))
            return visitClassDeclaration(node);
        if (ts.isEnumDeclaration(node))
            return visitEnumDeclaration(node);
        ts.forEachChild(node, generate);
    }
    function visitClassDeclaration(node) {
        var postable = false;
        if (node.decorators)
            node.decorators.forEach(function (deco) {
                if (deco.expression.getText() == 'Postable')
                    postable = true;
            });
        if (postable)
            usingClasses.add(node.name.getText());
    }
    function visitEnumDeclaration(node) {
        var postable = false;
        if (node.decorators)
            node.decorators.forEach(function (deco) {
                if (deco.expression.getText() == 'Postable')
                    postable = true;
            });
        if (postable)
            usingClasses.add(node.name.getText());
    }
    generate(node);
}
function __generate(node, usingClasses, result) {
    function generate(node) {
        if (ts.isClassDeclaration(node))
            return visitClassDeclaration(node);
        if (ts.isEnumDeclaration(node))
            return visitEnumDeclaration(node);
        ts.forEachChild(node, generate);
    }
    function visitEnumDeclaration(node) {
        if (!usingClasses.has(node.name.getText()))
            return;
        var members = [];
        node.members.forEach(function (mem) {
            var m = ts.createEnumMember(mem.name, null);
            members.push(m);
        });
        result.push(ts.createEnumDeclaration(null, null, node.name, members));
    }
    function visitClassDeclaration(node) {
        if (!usingClasses.has(node.name.getText()))
            return;
        var properties = [];
        ts.forEachChild(node, function (cbNode) {
            if (ts.isPropertyDeclaration(cbNode)) {
                var n = visitPropertyDeclaration(cbNode);
                if (n)
                    properties.push(n);
            }
            if (ts.isMethodDeclaration(cbNode)) {
                var n = visitMethodDeclaration(cbNode);
                if (n)
                    properties.push(n);
            }
        });
        var modifiers = [];
        if (node.modifiers)
            node.modifiers.forEach(function (m) {
                if (m.kind == ts.SyntaxKind.AbstractKeyword)
                    modifiers.push(m);
            });
        var heritages = [];
        if (node.heritageClauses)
            node.heritageClauses.forEach(function (hc) {
                if (hc.token != ts.SyntaxKind.ExtendsKeyword)
                    return;
                heritages.push(hc);
            });
        var heritage = node.heritageClauses;
        result.push(ts.createClassDeclaration(null, modifiers, node.name, node.typeParameters, heritages, properties));
    }
    function visitPropertyDeclaration(node) {
        var postable = false;
        if (node.decorators) {
            node.decorators.forEach(function (deco) {
                if (deco.expression.getText() == 'postable')
                    postable = true;
            });
        }
        if (postable)
            return ts.createProperty(null, node.modifiers, node.name.getText(), node.questionToken, node.type, null);
        return null;
    }
    function visitMethodDeclaration(node) {
        var postable = false;
        if (node.decorators) {
            node.decorators.forEach(function (deco) {
                if (deco.expression.getText() == 'postable')
                    postable = true;
            });
        }
        if (postable)
            return ts.createMethod(null, node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);
        return null;
    }
    generate(node);
}
function __generateExports(classes) {
    var specs = [];
    classes.forEach(function (node) {
        specs.push(ts.createExportSpecifier(node.name.getText(), 'I' + node.name.getText()));
    });
    // specs.push(ts.createExportSpecifier('registerPostable', 'registerPostable'));
    return ts.createExportDeclaration(null, null, ts.createNamedExports(specs));
}
function __generateRegister(classes) {
    return '';
    var str = '';
    for (var i = 0; i < classes.length; i++) {
        var node = classes[i];
        str += "store.set('" + node.name.getText() + "', " + node.name.getText() + ".constructor);\n";
    }
    return "function registerPostable(store) {\n    " + str + "\n  }";
}
