console.log('test')
// this example will create a simple typescript source file programmatically, parse it to AST Nodes and then 
// use TypeScript Transformations to manipulate some ot its nodes (changing  particular arithmetic expressions). 
// Finally , the transformed AST will be printed back to another source file as a string

// (Note: I've taken this example from somewhere else some credits are not mine - but since there's limited typescript 
// documentation I think is a good idea to duplicate this... )

import * as ts from 'typescript'
import * as fs from 'fs';
import * as path from 'path'
import * as program from 'commander'

program.version('1.0.0')
       .option('-i, --input <item>', 'Input path')
       .option('-o, --output <item>', 'Ouptut path')
       .parse(process.argv);

const inputDir = program.input ? program.input : process.cwd();
const outputPath = program.output ? program.output : process.cwd() + path.sep + 'worker-postable-generated.ts';
console.log(inputDir, outputPath);

var walkSync = function(dir, filelist) {
  var files = fs.readdirSync(dir);
  filelist = filelist || [];
  files.forEach(function(file) {
    if (fs.statSync(dir + file).isDirectory()) {
      const nextPath = path.normalize(dir + path.sep + file + path.sep);
      filelist = walkSync(nextPath, filelist);
    }
    else {
      const filename = path.normalize(dir + path.sep + file)
      if (/\.ts?/.test(path.extname(filename)))
        filelist.push(filename);
    }
  });
  return filelist;
};

const filelist = walkSync(inputDir + path.sep , []);
console.log(filelist)

let sourceFiles = [];
for (var i = 0; i < filelist.length; i ++) {
  var filepath = filelist[i];
  var source = fs.readFileSync(filepath).toString()
  if (source.indexOf('// Auto generated by worker-postable') == 0) continue;
  const sourceFile = ts.createSourceFile(
    filepath, source, ts.ScriptTarget.ES2015, true, ts.ScriptKind.TS);
  sourceFiles.push(sourceFile);
}
const generated = generate(sourceFiles)
fs.writeFileSync(outputPath, generated);


// Two-pass
// First pass : get all classes to recognize dependecy between classess (eg: extends)
// Second pass : generate classes

class ClassNode {
  node: ts.ClassDeclaration;
  extends: ts.HeritageClause;
}



function generate(sourceFiles: Array<ts.SourceFile>): string {
  let usingClasses = new Set<string>();
  let classess = new Array<ts.ClassDeclaration>();
  sourceFiles.forEach(node => {
    __pregenerate(node, usingClasses);
    __generate(node, usingClasses, classess);
  })
  let exports = __generateExports(classess);
  
  const printer: ts.Printer = ts.createPrinter()
  
  let resultString = '// Auto generated by worker-postable\n';
  console.log(classess.length)
  for (var i = 0; i < classess.length; i ++) {
    const str = printer.printNode(ts.EmitHint.Unspecified, classess[i], null)
    resultString += str + '\n';
  }

  let storeRegister = __generateRegister(classess);
  resultString += storeRegister + '\n'

  resultString += printer.printNode(ts.EmitHint.Unspecified, exports, null) + '\n'


  return resultString;
}

function __pregenerate(node: ts.Node, usingClasses: Set<string>) {
  function generate(node: ts.Node): void {
    if (ts.isClassDeclaration(node)) return visitClassDeclaration(node);
    ts.forEachChild(node, generate);
  }
  
  function visitClassDeclaration(node: ts.ClassDeclaration): void {
    let postable = false;
    if (node.decorators) node.decorators.forEach(deco => {
      if (deco.expression.getText() == 'Postable') postable = true;
    })
    if (postable) {
      usingClasses.add(node.name.getText());
      if (node.heritageClauses) node.heritageClauses.forEach(hc => {
        hc.types.forEach(t => {
          if (t) {
            usingClasses.add(t.getText())
          }
        })
      })
    }
  }

  generate(node);
}

function __generate(node: ts.Node, usingClasses: Set<string>, result: Array<ts.ClassDeclaration>) {

  function generate(node: ts.Node): void {
    if (ts.isClassDeclaration(node)) return visitClassDeclaration(node);
    ts.forEachChild(node, generate);
  }
  
  function visitClassDeclaration(node: ts.ClassDeclaration): void {
    if (!usingClasses.has(node.name.getText())) return;
    let properties: Array<ts.PropertyDeclaration> = [];
    ts.forEachChild(node, cbNode => {
      if (ts.isPropertyDeclaration(cbNode)) {
        let n = visitPropertyDeclaration(cbNode);
        if (n) properties.push(n);
      }
    });
    result.push(ts.createClassDeclaration(null, null, node.name, null, null, properties));
  }

  function visitPropertyDeclaration(node: ts.PropertyDeclaration): ts.PropertyDeclaration {
    let postable = false;
    if (node.decorators) {
      node.decorators.forEach(deco => {
        if (deco.expression.getText() == 'postable') postable = true;
      })
    }
    if (postable)
      return ts.createProperty(null, null, node.name.getText(), node.questionToken, node.type, null);
    return null;
  }

  generate(node);
}

function __generateExports(classes: Array<ts.ClassDeclaration>): ts.ExportDeclaration {
  let specs = [];
  classes.forEach(node => {
    specs.push(ts.createExportSpecifier(node.name.getText(), node.name.getText()));
  })
  specs.push(ts.createExportSpecifier('registerPostable', 'registerPostable'));
  return ts.createExportDeclaration(null, null, ts.createNamedExports(specs));
}

function __generateRegister(classes: Array<ts.ClassDeclaration>): string {
  var str = '';
  for (var i = 0; i < classes.length; i ++) {
    var node = classes[i];
    str += `store.set('${node.name.getText()}', ${node.name.getText()}.constructor);\n`
  }
  return `function registerPostable(store) {
    ${str}
  }`;
}